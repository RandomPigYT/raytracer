#version 450 core



layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (rgba32f, binding = 0) uniform image2D rendered;


struct Vertex {
	
	vec4 position;
	vec4 normal;
	vec4 texelCoord;

};

struct Material {
	
	vec3 kd;
	vec2 alpha;
	vec3 ks;
	vec3 emission;

};

struct Mesh {
	
	uint startingVertex;
	uint numTriangles;
	uint materialID;
	uint objectID;

};

struct Object {

	vec3 pos;
	uint id;

};

layout (std430, binding = 0) buffer Verts{
	Vertex verts[];
};

layout (std140, binding = 1) buffer Materials {
	Material materials[];
};

layout (std140, binding = 2) buffer Meshes {
	Mesh meshes;
};

layout (std140, binding = 3) buffer Objects {
	Object objects;
};

uniform vec3 cameraPos;
uniform vec3 cameraDir;

mat3 genRotationMatrix(vec3 axis, float theta){

	mat3 rotate;

	rotate[0] = vec3(cos(theta) + (axis.x * axis.x) * (1 - cos(theta)),
									(axis.y * axis.x) * (1 - cos(theta)) + axis.z * sin(theta),
									(axis.z * axis.x) * (1 - cos(theta)) - axis.y * sin(theta));

	rotate[1] = vec3((axis.x * axis.y) * (1 - cos(theta)) - axis.z * sin(theta),
									cos(theta) + (axis.y * axis.y) * (1 - cos(theta)),
									(axis.z * axis.y) * (1 - cos(theta)) + axis.x * sin(theta));
	
	rotate[2] = vec3((axis.x * axis.z) * (1 - cos(theta)) + axis.y * sin(theta),
									(axis.y * axis.z) * (1 - cos(theta)) - axis.x * sin(theta),
									cos(theta) + (axis.z * axis.z) * (1 - cos(theta)));
	
	return rotate;
}

bool testIntersect(Vertex v[3], vec3 rayOrigin, vec3 rayDir ){
	float epsilon = 0.0000001;

	vec3 positions[] = {v[0].position.xyz, v[1].position.xyz, v[2].position.xyz};
	
	vec3 edge1 = positions[1] - positions[0];
	vec3 edge2 = positions[2] - positions[0];

	vec3 cross_rayDir_edge2 = cross(rayDir, edge2);
	
	double det = dot(edge1, cross_rayDir_edge2);

	if (det > -epsilon && det < epsilon)
		return false;

	double invDet = 1 / det;

	vec3 origMinusPos0 =  rayOrigin - positions[0];

	double baryU = dot(origMinusPos0, cross_rayDir_edge2) * invDet;
	if (baryU < 0.0 || baryU > 1.0)
		return false;
	
	
	vec3 cross_oriMinusPos0_edge1 = cross(origMinusPos0, edge1);

	double baryV = dot(rayDir, cross_oriMinusPos0_edge1) * invDet;
	if (baryV < 0 || baryU + baryV > 1.0)
		return false;
	
	return true;
}

vec3 getRayDir(float dist, float fov, vec2 resolution){

	float l = dist * tan(radians(fov / 2));

	float planeWidth = 2 * l;
	float planeHeight = 1.125f * l;

	float pixelWidth = planeWidth / resolution[0];
	float pixelHeight = planeHeight / resolution[1];

	float wCentreOffset = 0.5 * pixelWidth;
	float hCentreOffset = 0.5 * pixelHeight;
	
	vec3 rayDir = normalize(vec3((gl_GlobalInvocationID.x * pixelWidth) + wCentreOffset,
													(gl_GlobalInvocationID.y * pixelHeight) + hCentreOffset, dist));


		
	
	vec3 crossed = cross(cameraDir, vec3(0.0f, 0.0f, 1.0f));
	vec3 axis = normalize(crossed);
		
	float magnitude = sqrt((crossed[0] * crossed[0]) + (crossed[1] * crossed[1]) + (crossed[2] * crossed[2]));
	float theta = asin(magnitude);
	
	mat3 rotate = genRotationMatrix(axis, -theta);

	return rotate * rayDir;
}


void main(){

	vec4 colour = vec4(0.0, 0.0, 0.0, 1.0);


	float fov = 90;
	float nearPlane = 0.1;


//for (int i = 0; i < verts.length() / 3; i += 3){
//		
//	Vertex temp[] = {verts[i], verts[i + 1], verts[i + 2]};
//	
//	if(testIntersect(temp, cameraPos, getRayDir(0.1, fov, ivec2(1920, 1080)))){

//		colour = vec4(1.0, 0.0, 0.0, 1.0);
//		break;
//	}

//}
//
//
//
	

	
	for (int i = 0; i < verts.length(); i++){

		if (verts[i].position.x != 0.0f)
			colour = vec4(1, 0, 0, 1);
	}
	
	if (colour == vec4(1, 0, 0, 1)){
		for (int i = 0; i < verts.length(); i++){
			if (verts[i].position.y != 0.0f)
				colour = vec4(0, 1, 0, 1);
		}
	}

	if(colour == vec4(0, 1, 0, 1)){
		for (int i = 0; i < verts.length(); i++){
			if (verts[i].position.z != 0.0f)
				colour = vec4(0, 0, 1, 1);

		}
	}

	for (int i = 0; i < verts.length(); i++){
		if ((verts[i].position.xyz == vec3(0.5, -0.5, 0)))
			colour = vec4(1, 1, 1, 1);
	}

	vec4 value = vec4(0.0, 0.0, 0.0, 1.0);
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

	value.x = float(texelCoord.x)/(gl_NumWorkGroups.x);
	value.y = float(texelCoord.y)/(gl_NumWorkGroups.y);
	
	imageStore(rendered, texelCoord, colour);
}

