#version 450 core

#define NUM_INVOCATIONS_PER_GROUP_X 40
#define NUM_INVOCATIONS_PER_GROUP_Y 24

layout(local_size_x = NUM_INVOCATIONS_PER_GROUP_X,
       local_size_y = NUM_INVOCATIONS_PER_GROUP_Y, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D rendered;

#define RAND_MAX 0xffffffffu
#define PI radians(180)

struct Vertex {
  vec4 position;
  vec4 normal;
  vec2 texelCoord;
};

struct Material {
  vec4 albedo;
  vec4 emission;
  vec4 intensity;
  vec4 refractiveIndex;
  vec2 roughness;
  float metallic;
  float reflectance;
};

struct Mesh {
  uint startingVertex;
  uint numTriangles;
  uint materialID;
  uint objectID;
};

struct Object {
  vec3 pos;
  uint id;
};

struct Sphere {
  vec4 position;
  float radius;

  uint materialID;
};

struct HitInfo {
  bool didHit;
  vec3 normal;
  float rayT;
  vec3 position;
};

layout(std430, binding = 0) buffer Verts { Vertex verts[]; };

layout(std430, binding = 4) buffer sphereBuf { Sphere spheres[]; };

layout(std140, binding = 1) buffer Materials { Material materials[]; };

layout(std140, binding = 2) buffer Meshes { Mesh meshes; };

layout(std140, binding = 3) buffer Objects { Object objects; };

uniform vec3 cameraPos;
uniform vec3 cameraDir;

uniform uint raysPerPixel;
uniform uint maxBounces;

uniform vec2 resolution;

uniform uint time;
uniform uint frameNum;

uniform mat4 camToWorld;

uniform float fov;
uniform float blurStrength;

uint pcg_hash(uint inp) {
  uint state = inp * 747796405u + 2891336453u;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  return (word >> 22u) ^ word;
}

float random(inout uint seed) {
  seed = pcg_hash(seed);

  return seed / float(RAND_MAX);
}


HitInfo testSphereIntersect(vec3 rayOrigin, vec3 rayDir, Sphere s) {
  HitInfo h;
  h.didHit = true;

  vec3 translatedRayOrig = rayOrigin - s.position.xyz;

  float a = dot(rayDir, rayDir);
  float b = dot(translatedRayOrig, rayDir) * 2;
  float c = dot(translatedRayOrig, translatedRayOrig) - (s.radius * s.radius);

  float discriminant = (b * b) - (4 * a * c);

  if (discriminant < 0) {
    h.didHit = false;
    return h;
  }

  float t_0 = (-b - sqrt(discriminant)) / (2 * a);
  float t_1 = (-b + sqrt(discriminant)) / (2 * a);

  if (t_0 < 0 && t_1 < 0) {
    h.didHit = false;
    return h;
  }

  h.rayT = t_0 >= 0 ? t_0 : t_1;
  h.position = rayOrigin + rayDir * h.rayT;
  h.normal = normalize(h.position - s.position.xyz);

  return h;
}

mat4 lookat(vec3 eye, vec3 at, vec3 up){

  vec3 zAxis = normalize(at - eye);
  vec3 xAxis = normalize(cross(zAxis, up));
  vec3 yAxis = normalize(cross(xAxis, zAxis));

  zAxis = -zAxis;

  mat4 mat = {
    vec4(xAxis, 0),
    vec4(yAxis, 0),
    vec4(zAxis, 0),
    vec4(0, 0, 0, 1)
  };

  return mat;
}

vec3 getRayDir(float fov /* in degrees */, float aspectRatio) {
  vec2 texelCoord = gl_GlobalInvocationID.xy;
  vec2 ndc = vec2((texelCoord.x + 0.5) / (resolution[0]),
                  (texelCoord.y + 0.5) / (resolution[1]));

  vec2 pixelCamera;
  pixelCamera.x = ((2 * ndc.x) - 1) * aspectRatio * tan(radians(fov / 2));
  pixelCamera.y = ((2 * ndc.y) - 1) * tan(radians(fov / 2));

  vec3 rayDir = normalize((camToWorld * vec4(pixelCamera, -1.0f, 0)).xyz);
  // vec3 rayDir = normalize((lookat(vec3(0, 0, 0), cameraDir, vec3(0, 1, 0))) * vec4(pixelCamera, -1.0f, 0)).xyz;

  return rayDir;
}


HitInfo closestSphereHIt(out uint index, vec3 rayDir, vec3 rayOrigin){

  HitInfo minHit;
  minHit.rayT = 1.0 / 0.0;
  minHit.didHit = false;

  uint minIndex = -1;
  
  for (int i = 0; i < spheres.length(); i++){

    HitInfo h = testSphereIntersect(rayOrigin, rayDir, spheres[i]);
    if (!h.didHit)
      continue;

    

    if (h.rayT < minHit.rayT){
      minHit = h;
      minIndex = i;
      minHit.didHit = true;
    }
  }
  
  index = minIndex;
  return minHit;
}

vec3 getSpecularReflectedRay(float roughness, vec3 surfaceNormal, vec3 rayDir, 
                                inout uint seed, out float theta, out float phi, out vec3 microfacetN){




  float alpha = roughness * roughness;
  float alpha2 = alpha * alpha;

  uint temp = seed;
  
  float xi_1 = random(temp);
  float xi_2 = random(temp);


  seed = temp;

  theta = atan(alpha * sqrt(xi_1 / (1 - xi_1)));
  // theta = atan(sqrt(-alpha2 * log(1 - xi_1)));
  phi = 2 * PI * xi_2;

  microfacetN = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
  // normal = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));
  microfacetN = (lookat(vec3(0, 0, 0), -surfaceNormal, vec3(0, 1, 0)) * vec4(microfacetN, 0)).xyz;
  microfacetN = normalize(microfacetN);

  vec3 reflected = reflect(rayDir, microfacetN);

  return reflected;
}


vec3 getDiffuseReflectedRay(vec3 surfaceNormal, inout uint seed, out float theta, out float phi){

  vec3 normal;

  float xi_1 = random(seed);
  float xi_2 = random(seed);

  phi = 2 * PI * xi_2;
  theta = acos(sqrt(xi_1));

  normal = normalize(vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta)));
  normal = (lookat(vec3(0, 0, 0), -surfaceNormal, vec3(0, 1, 0)) * vec4(normal, 0)).xyz;

  return normal;
}

float lambertianPDF(vec3 view, vec3 normal){
  return dot(view, normal) / PI;
}

vec3 lambertianBRDF(vec3 view, vec3 normal, vec3 albedo){
  return (albedo * dot(view, normal)) / PI;
}


vec3 calculateFresnel(float VdotH, vec3 f0){

  return f0 + ((1.0 - f0) * pow(1.0 - VdotH, 5.0));
}

float GGXDistribution(float alpha, float NdotH){

  float alpha2 = alpha * alpha;

  float b = ((alpha2 - 1.0) * NdotH * NdotH) + 1;

  if (alpha == 0)
    return 1;

  if (!(NdotH > 0))
    return 0;

  return (alpha2 / (PI * b * b));
}

float beckmannDist(float alpha, float NdotH){

  float alpha2 = alpha * alpha;

  float theta = acos(NdotH);

  float den = PI * alpha2 * pow(NdotH, 4.0);
  float num = exp(-(tan(theta) * tan(theta)) / alpha2);

  return num / den;
}

float schlickG1(float NdotX, float alpha){
  float k = max(alpha / 2, 0.001);

  // if (NdotX <= 0.001 && alpha <= 0.001)
  //   return 1;

  return NdotX / (NdotX * (1 - k) + k);
}

float smithG2(float NdotV, float NdotL, float alpha){
  return schlickG1(NdotV, alpha) * schlickG1(NdotL, alpha);
}


vec3 GGXbrdf(vec3 V, vec3 L, vec3 N, Material mat){


  vec3 H = normalize(V + L);

  float NdotV = clamp(dot(N, V), 0.0, 1.0);
  float NdotL = clamp(dot(N, L), 0.0, 1.0);
  float NdotH = clamp(dot(N, H), 0.0, 1.0);
  float VdotH = clamp(dot(V, H), 0.0, 1.0);
  float LdotH = clamp(dot(L, H), 0.0, 1.0);

  float alpha = mat.roughness.x * mat.roughness.x;

  vec3 f0 = vec3(0.16 * mat.reflectance);
  f0 = mix(f0, mat.albedo.xyz, mat.metallic);

  vec3 F = calculateFresnel(VdotH, f0);


  float D = GGXDistribution(alpha, NdotH);

  // float D = 0.4;
  // float D = beckmannDist(alpha, NdotH);
  float G = smithG2(NdotV, NdotL, alpha);


  // vec3 brdf = (F * D * G) / (4 * NdotL * NdotV + 0.0001) ;
  vec3 brdf = (F * D * G) / (4 * max(NdotL, 0.001) * max(NdotV, 0.001));
  // vec3 brdf = (F * D * G);

  return brdf;
}


float GGXpdf(float roughness, vec3 H, vec3 N, vec3 L, float reflectance){

  float alpha = roughness * roughness;

  // if (roughness == 0)
  //   return 1;

  float t = reflectance * reflectance;
  
  float alpha2 = alpha * alpha;


  float NdotH = clamp(dot(N, H), 0.0, 1.0);
  float LdotH = clamp(dot(L, H), 0.0, 1.0);
  float NdotL = clamp(dot(N, L), 0.0, 1.0);


  float term1 = (1 - t) * NdotL / PI;

  float num = max(GGXDistribution(alpha, NdotH), 0.001) * max(NdotH, 0.001);

  float term2 = (t * num) / (4 * LdotH);

  return term1 + term2;
}


vec4 trace(vec3 rayDir, vec4 bgColour, inout uint seed){

  
  vec3 rayOrigin = cameraPos;

  vec3 colour = vec3(0, 0, 0);
  vec3 throughput = vec3(1.0, 1.0, 1.0);

  HitInfo hit;
  uint sphereIndex;

  Material mat;
  float mult = 1.0f;

  // uint seed = frameNum * (gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(resolution.y)) * time;
  uint prevSeed = seed;

  float bgIntensity = 1.0;

  for (int i = 0; i <= maxBounces; i++){


    
    hit = closestSphereHIt(sphereIndex, rayDir, rayOrigin);
    

    if (!hit.didHit){
      
      if (i != 0){
        colour += bgColour.xyz * throughput * bgIntensity;
      }

      else
        colour +=  bgColour.xyz * throughput;


      break;
    }


    mat = materials[spheres[sphereIndex].materialID];




    float probability = 1.0f;

    float theta, phi;

    float xi = random(seed);
    bool isSpecular = false;

    if (xi < mat.reflectance * mat.reflectance){
      isSpecular = true;
      probability *= mat.reflectance;
    }
    
    else {
      probability *= 1.0 - mat.reflectance * mat.reflectance;
    }


    vec3 microfacetN;
    vec3 reflectedRay = isSpecular ? getSpecularReflectedRay(mat.roughness.x, hit.normal, rayDir, seed, theta, phi, microfacetN) : 
                                    getDiffuseReflectedRay(hit.normal, seed, theta, phi);


    if (dot(reflectedRay, hit.normal) <= 0.001){
      
      colour += throughput * mat.emission.xyz * mat.intensity.x;
      break;
    }
    

  

    vec3 brdf = isSpecular ? GGXbrdf(-rayDir, reflectedRay, hit.normal, mat) : lambertianBRDF(-rayDir, hit.normal, mat.albedo.xyz);


    vec3 H = normalize(-rayDir + reflectedRay);
    float pdf = isSpecular ?  GGXpdf(mat.roughness.x, H, hit.normal, reflectedRay, mat.reflectance) : 1 / PI;

    // pdf = isSpecular ? 1.0 : pdf;
    // if (isSpecular){
    //   brdf = vec3(1);
    //   pdf = 1.0;
    // }
    colour += throughput * mat.emission.xyz * mat.intensity.x;
    throughput *= brdf / (pdf);

    // if (isnan(colour.x) || isnan(colour.y) || isnan(colour.z) || isnan(pdf))
    //   return vec4(1, 0, 1, 1);
    
    // if (pdf == 0)
    //   return vec4(1, 0, 0, 1);


    // throughput *= mat.albedo.xyz;

    rayDir = reflectedRay;
    vec3 offset = rayDir * 0.001;

    rayOrigin = hit.position + offset;
  }

  return vec4(colour, 1);
}


void main() {

  
  vec4 colour = vec4(0, 0, 0, 1);


  float aspectRatio = (resolution[0]) / (resolution[1]);
  vec3 rayDir = getRayDir(fov, aspectRatio);

  float pixelLength = (2 * tan(radians(fov / 2)) * aspectRatio * blurStrength) / resolution[0];
  float pixelHeight = (2 * tan(radians(fov / 2)) * blurStrength) / resolution[1];


  uint seed = frameNum * gl_GlobalInvocationID.x * gl_GlobalInvocationID.y * time;
  

  for (int i = 0; i < raysPerPixel; i++){ 

    vec3 offset = vec3((random(seed) * 2 - 1) * pixelLength, (random(seed) * 2 - 1) * pixelHeight, 0);

    // colour += trace(rayDir + offset, vec4(0.196, 0.427, 0.78, 1)) / raysPerPixel;
    colour += trace(rayDir + offset, vec4(0, 0, 0, 1), seed) / raysPerPixel; 
  }


  ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);




  if (gl_GlobalInvocationID.x < uint(resolution[0]) && gl_GlobalInvocationID.y < uint(resolution[1]) && frameNum == 1)
    imageStore(rendered, texelCoord, colour);

  else{

    vec4 prevColour = imageLoad(rendered, texelCoord);
    colour = ((frameNum - 1) * prevColour + colour) / frameNum;
    imageStore(rendered, texelCoord, colour);

  }

}
