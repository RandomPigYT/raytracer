#version 450 core

#define NUM_INVOCATIONS_PER_GROUP_X 40
#define NUM_INVOCATIONS_PER_GROUP_Y 24

layout(local_size_x = NUM_INVOCATIONS_PER_GROUP_X,
       local_size_y = NUM_INVOCATIONS_PER_GROUP_Y, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D rendered;

#define RAND_MAX 0xffffffffu

struct Vertex {
  vec4 position;
  vec4 normal;
  vec2 texelCoord;
};

struct Material {
  vec4 kd;
  vec4 ks;
  vec4 emission;
  vec4 intensity;
  vec4 refractiveIndex;
  vec2 alpha;
  float metallicity;
};

struct Mesh {
  uint startingVertex;
  uint numTriangles;
  uint materialID;
  uint objectID;
};

struct Object {
  vec3 pos;
  uint id;
};

struct Sphere {
  vec4 position;
  float radius;

  uint materialID;
};

struct HitInfo {
  bool didHit;
  vec3 normal;
  float rayT;
  vec3 position;
};

layout(std430, binding = 0) buffer Verts { Vertex verts[]; };

layout(std430, binding = 4) buffer sphereBuf { Sphere spheres[]; };

layout(std140, binding = 1) buffer Materials { Material materials[]; };

layout(std140, binding = 2) buffer Meshes { Mesh meshes; };

layout(std140, binding = 3) buffer Objects { Object objects; };

uniform vec3 cameraPos;
uniform vec3 cameraDir;

uniform uint raysPerPixel;
uniform uint maxBounces;

uniform vec2 resolution;

uniform uint time;
uniform uint frameNum;

uniform mat4 camToWorld;

uint pcg_hash(uint inp) {
  uint state = inp * 747796405u + 2891336453u;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  return (word >> 22u) ^ word;
}

float random(inout uint seed) {
  seed = pcg_hash(seed);

  return seed / float(RAND_MAX);
}

HitInfo testIntersect(Vertex v[3], vec3 rayOrigin, vec3 rayDir) {
  float epsilon = 0.0000001;

  HitInfo h;
  h.didHit = true;

  vec3 positions[] = {v[2].position.xyz, v[1].position.xyz, v[0].position.xyz};

  vec3 edge1 = positions[2] - positions[0];
  vec3 edge2 = positions[1] - positions[0];

  vec3 cross_rayDir_edge2 = cross(rayDir, edge2);

  double det = dot(edge1, cross_rayDir_edge2);

  if (det < epsilon) {
    h.didHit = false;
    return h;
  }
  if (det > -epsilon && det < epsilon) {
    h.didHit = false;
    return h;
  }

  double invDet = 1 / det;

  vec3 origMinusPos0 = rayOrigin - positions[0];

  double baryU = dot(origMinusPos0, cross_rayDir_edge2) * invDet;
  if (baryU < 0.0 || baryU > 1.0) {
    h.didHit = false;
    return h;
  }

  vec3 cross_oriMinusPos0_edge1 = cross(origMinusPos0, edge1);

  double baryV = dot(rayDir, cross_oriMinusPos0_edge1) * invDet;
  if (baryV < 0 || baryU + baryV > 1.0) {
    h.didHit = false;
    return h;
  }
  double rayT;

  h.rayT = dot(edge2, cross_oriMinusPos0_edge1) * float(invDet);

  if (h.rayT < 0) {
    h.didHit = false;

    return h;
  }

  h.position = rayOrigin + rayDir * h.rayT;
  h.normal = cross(edge1, edge2);

  return h;
}

HitInfo testSphereIntersect(vec3 rayOrigin, vec3 rayDir, Sphere s) {
  HitInfo h;
  h.didHit = true;

  vec3 translatedRayOrig = rayOrigin - s.position.xyz;

  float a = dot(rayDir, rayDir);
  float b = dot(translatedRayOrig, rayDir) * 2;
  float c = dot(translatedRayOrig, translatedRayOrig) - (s.radius * s.radius);

  float discriminant = (b * b) - (4 * a * c);

  if (discriminant < 0) {
    h.didHit = false;
    return h;
  }

  float t_0 = (-b - sqrt(discriminant)) / (2 * a);
  float t_1 = (-b + sqrt(discriminant)) / (2 * a);

  if (t_0 < 0 && t_1 < 0) {
    h.didHit = false;
    return h;
  }

  h.rayT = t_0 >= 0 ? t_0 : t_1;
  h.position = rayOrigin + rayDir * h.rayT;
  h.normal = normalize(h.position - s.position.xyz);

  return h;
}

mat4 lookat(vec3 eye, vec3 at, vec3 up){

  vec3 zAxis = normalize(at - eye);
  vec3 xAxis = normalize(cross(zAxis, up));
  vec3 yAxis = normalize(cross(xAxis, zAxis));

  zAxis = -zAxis;

  mat4 mat = {
    vec4(xAxis, 0),
    vec4(yAxis, 0),
    vec4(zAxis, 0),
    vec4(0, 0, 0, 1)
  };

  return mat;
}

vec3 getRayDir(float fov /* in degrees */, float aspectRatio) {
  vec2 texelCoord = gl_GlobalInvocationID.xy;
  vec2 ndc = vec2((texelCoord.x + 0.5) / (resolution[0]),
                  (texelCoord.y + 0.5) / (resolution[1]));

  vec2 pixelCamera;
  pixelCamera.x = ((2 * ndc.x) - 1) * aspectRatio * tan(radians(fov / 2));
  pixelCamera.y = ((2 * ndc.y) - 1) * tan(radians(fov / 2));

  vec3 rayDir = normalize((camToWorld * vec4(pixelCamera, -1.0f, 0)).xyz);
  // vec3 rayDir = normalize((lookat(vec3(0, 0, 0), cameraDir, vec3(0, 1, 0))) * vec4(pixelCamera, -1.0f, 0)).xyz;

  return rayDir;
}


HitInfo closestSphereHIt(out uint index, vec3 rayDir, vec3 rayOrigin){

  HitInfo minHit;
  minHit.rayT = 1.0 / 0.0;
  minHit.didHit = false;

  uint minIndex = -1;
  
  for (int i = 0; i < spheres.length(); i++){

    HitInfo h = testSphereIntersect(rayOrigin, rayDir, spheres[i]);
    if (!h.didHit)
      continue;

    

    if (h.rayT < minHit.rayT){
      minHit = h;
      minIndex = i;
      minHit.didHit = true;
    }
  }
  
  index = minIndex;
  return minHit;
}


vec4 trace(vec3 rayDir, vec4 bgColour){

  vec3 rayOrigin = cameraPos;

  vec3 colour = vec3(0, 0, 0);
  vec3 throughput = vec3(1.0, 1.0, 1.0);

  HitInfo hit;
  uint sphereIndex;

  Material mat;
  float mult = 1.0f;

  uint seed = frameNum * gl_GlobalInvocationID.x * gl_GlobalInvocationID.y * time;
  uint prevSeed = seed;

  for (int i = 0; i <= maxBounces; i++){
    
    hit = closestSphereHIt(sphereIndex, rayDir, rayOrigin);
    if (!hit.didHit){
      
      colour +=  bgColour.xyz * throughput;
      break;
    }

    vec3 lightDir = normalize(vec3(-1, -1, -1));
    float intensity = max(dot(hit.normal, -lightDir), 0);

    mat = materials[spheres[sphereIndex].materialID];

    vec3 sphereCol = mat.kd.xyz;
    sphereCol *= intensity;

    colour += throughput * mat.emission.xyz * mat.intensity.x;

    throughput *= mat.kd.xyz;
    
    float theta = acos(sqrt(random(seed)));
    float phi = 2 * radians(180) * random(seed);

    rayDir = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));

    rayDir = (lookat(vec3(0, 0, 0), -hit.normal, vec3(0, 1, 0)) * vec4(rayDir, 0)).xyz;

    // rayDir = normalize(reflect(rayDir, hit.normal));
    vec3 offset = rayDir * 0.001;
    rayOrigin = hit.position + offset;

    mult *= 0.7f;
  }

  return vec4(colour, 1);
}


void main() {

  
  vec4 colour = vec4(0, 0, 0, 1);

  float aspectRatio = (resolution[0]) / (resolution[1]);
  vec3 rayDir = getRayDir(70, aspectRatio);


  for (int i = 0; i < raysPerPixel; i++){

    // colour += trace(rayDir, vec4(0.51, 0.71, 1, 1)) / raysPerPixel;
    colour += trace(rayDir, vec4(0, 0, 0, 1)) / raysPerPixel; 
  }

  // colour = rayTrace(rayDir, vec4(0, 0, 0, 1));

  ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);




  if (gl_GlobalInvocationID.x < uint(resolution[0]) && gl_GlobalInvocationID.y < uint(resolution[1]) && frameNum == 0)
    imageStore(rendered, texelCoord, colour);

  else{

    vec4 prevColour = imageLoad(rendered, texelCoord);
    colour = ((frameNum - 1) * prevColour + colour) / frameNum;
    imageStore(rendered, texelCoord, colour);

  }

}
