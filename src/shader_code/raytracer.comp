#version 450 core



layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

layout (rgba32f, binding = 0) uniform image2D rendered;


struct Vertex {
	
	vec4 position;
	vec4 normal;
	vec2 texelCoord;

};

struct Material {
	
	vec3 kd;
	vec2 alpha;
	vec3 ks;
	vec3 emission;

};

struct Mesh {
	
	uint startingVertex;
	uint numTriangles;
	uint materialID;
	uint objectID;

};

struct Object {

	vec3 pos;
	uint id;

};

layout (std430, binding = 0) buffer Verts{
	Vertex verts[];
};

layout (std140, binding = 1) buffer Materials {
	Material materials[];
};

layout (std140, binding = 2) buffer Meshes {
	Mesh meshes;
};

layout (std140, binding = 3) buffer Objects {
	Object objects;
};

uniform vec3 cameraPos;
uniform vec3 cameraDir;

uniform uint raysPerPixel;
uniform uint maxBounces;




vec2 testIntersect(Vertex v[3], vec3 rayOrigin, vec3 rayDir ){
	float epsilon = 0.0000001;

	vec3 positions[] = {v[0].position.xyz, v[1].position.xyz, v[2].position.xyz};
	
	vec3 edge1 = positions[1] - positions[0];
	vec3 edge2 = positions[2] - positions[0];

	vec3 cross_rayDir_edge2 = cross(rayDir, edge2);
	
	double det = dot(edge1, cross_rayDir_edge2);

	if (det > -epsilon && det < epsilon)
		return vec2(0, 0);

	double invDet = 1 / det;

	vec3 origMinusPos0 =  rayOrigin - positions[0];

	double baryU = dot(origMinusPos0, cross_rayDir_edge2) * invDet;
	if (baryU < 0.0 || baryU > 1.0)
		return vec2(0, 0);
	
	
	vec3 cross_oriMinusPos0_edge1 = cross(origMinusPos0, edge1);

	double baryV = dot(rayDir, cross_oriMinusPos0_edge1) * invDet;
	if (baryV < 0 || baryU + baryV > 1.0)
		return vec2(0, 0);
	
	double rayT;

	rayT = dot(edge2, cross_oriMinusPos0_edge1) * invDet;
	return vec2(1, rayT);
}


vec3 getRayDir(float dist, float fov, vec2 resolution){
	
	
	vec3 rayDir;

	return rayDir;
}

vec3 getRayDirNaive(){
	
	
	vec2 texelCoord = gl_GlobalInvocationID.xy;

	vec2 uv = vec2(texelCoord.x / gl_NumWorkGroups.x, texelCoord.y / gl_NumWorkGroups.y);
	uv = normalize(uv * 2.0f - 1.0f);

	vec3 rayDir = vec3(uv, 1.0f);


	return rayDir;
}




void main(){

	vec4 colour = vec4(0, 0, 0, 1);

	vec3 rayDir = getRayDirNaive();

	for (int i = 0; i < verts.length() / 3; i += 3){
		
		Vertex temp[] = {verts[i], verts[i + 1], verts[i + 2]};
		vec2 intersectResult = testIntersect(temp, cameraPos, rayDir);

		if (intersectResult[0] == 1){
			
			colour = vec4(verts[i].normal.xyz, 1.0);
			
		}

	}
	

	vec4 value = vec4(0.0, 0.0, 0.0, 1.0);
	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);

	value.x = float(texelCoord.x)/(gl_NumWorkGroups.x);
	value.y = float(texelCoord.y)/(gl_NumWorkGroups.y);
	
	imageStore(rendered, texelCoord, colour);
}

