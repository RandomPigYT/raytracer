/*Any piece of code wrapped in SRC(<source>){} indicates that the code has been copied from another location.
  The <source> specifies the source.*/

#version 450 core

#extension GL_ARB_bindless_texture : require

#define NUM_INVOCATIONS_PER_GROUP_X 40
#define NUM_INVOCATIONS_PER_GROUP_Y 24

layout(local_size_x = NUM_INVOCATIONS_PER_GROUP_X,
       local_size_y = NUM_INVOCATIONS_PER_GROUP_Y, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D rendered;


#define RAND_MAX 0xffffffffu
#define PI radians(180)

// #define NO_BVH


struct Vertex {
  vec4 position;
  vec4 normal;
  vec2 texelCoord;
};

struct Material {
  vec4 albedo;
  vec4 emission;
  vec4 intensity;
  vec4 refractiveIndex;
  vec4 transmittance;
  vec2 roughness;
  float metallic;
  float reflectance;
  float opacity;
  float transmissionRoughness;
  int textureID;
  int roughnessMapID;
  int metallicMapID;
  int emissiveMapID;
  int normalMapID;
  int opacityMapID;
  int specularMapID;
  int displacementMapID;
};

struct Mesh {
  uint startingVertex;
  uint numTriangles;
  uint materialID;
  uint objectID;
  mat4 transform;
};

struct Object {
  mat4 transform;
  uint id;
  uint startingMesh;
  uint numMeshes;
};

struct Sphere {
  vec4 position;
  float radius;

  uint materialID;
};

struct HitInfo {
  bool didHit;
  vec3 normal;
  float rayT;
  vec3 position;
  vec3 bary;
};

struct Bvh {
  vec4 corner1;
  vec4 corner2;
  int hitIndex;
  int missIndex;
  uint numTris;
  uint triIndices[4];
};

layout(std430, binding = 0) buffer Verts { Vertex verts[]; };

layout(std140, binding = 1) buffer Materials { Material materials[]; };

layout(std140, binding = 2) buffer Meshes { Mesh meshes[]; };

layout(std140, binding = 3) buffer Objects { Object objects[]; };

layout(std430, binding = 4) buffer sphereBuf { Sphere spheres[]; };

layout(std430, binding = 5) buffer Bvhs { Bvh bvhs[]; };

layout(std430, binding = 6) buffer VertMeshRel { uint vertMeshRel[]; };

layout(std430, binding = 7) buffer Textures { sampler2D textures[]; };

uniform vec3 cameraPos;
uniform vec3 cameraDir;

uniform uint raysPerPixel;
uniform uint maxBounces;

uniform vec2 resolution;

uniform uint time;
uniform uint frameNum;

uniform mat4 camToWorld;

uniform float fov;
uniform float blurStrength;

uint pcg_hash(uint inp) {
  uint state = inp * 747796405u + 2891336453u;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  return (word >> 22u) ^ word;
}

float random(inout uint seed) {
  seed = pcg_hash(seed);

  return seed / float(RAND_MAX);
}

HitInfo testSphereIntersect(vec3 rayOrigin, vec3 rayDir, Sphere s) {
  HitInfo h;
  h.didHit = true;

  vec3 translatedRayOrig = rayOrigin - s.position.xyz;

  float a = dot(rayDir, rayDir);
  float b = dot(translatedRayOrig, rayDir) * 2;
  float c = dot(translatedRayOrig, translatedRayOrig) - (s.radius * s.radius);

  float discriminant = (b * b) - (4 * a * c);

  if (discriminant < 0) {
    h.didHit = false;
    return h;
  }

  float t_0 = (-b - sqrt(discriminant)) / (2 * a);
  float t_1 = (-b + sqrt(discriminant)) / (2 * a);

  if (t_0 < 0 && t_1 < 0) {
    h.didHit = false;
    return h;
  }

  h.rayT = t_0 >= 0 ? t_0 : t_1;
  h.position = rayOrigin + rayDir * h.rayT;
  h.normal = normalize(h.position - s.position.xyz);

  return h;
}

vec3 barycentricCoords(vec3 verts[3], vec3 p){
  vec3 v0 = verts[1] - verts[0];
  vec3 v1 = verts[2] - verts[0];
  vec3 v2 = p - verts[0];

  float d00 = dot(v0, v0);
  float d01 = dot(v0, v1);
  float d11 = dot(v1, v1);
  float d20 = dot(v2, v0);
  float d21 = dot(v2, v1);

  float invdenom = 1 / (d00 * d11 - d01 * d01);

  float v = (d11 * d20 - d01 * d21) * invdenom;
  float w = (d00 * d21 - d01 * d20) * invdenom;
  float u = (1.0f - v - w);

  return vec3(u, v, w);
}

HitInfo triangleIntersect(vec3 vertices[3], vec3 normals[3], vec3 rayDir, vec3 rayOrigin, mat4 transform){
  HitInfo h;
  h.didHit = true;

  // vec3 untransformedRayOrig = rayOrigin;
  // rayOrigin -= pos;
  vertices[0] = (transform * vec4(vertices[0], 1.0f)).xyz; 
  vertices[1] = (transform * vec4(vertices[1], 1.0f)).xyz; 
  vertices[2] = (transform * vec4(vertices[2], 1.0f)).xyz; 

  mat4 rotate = transform;
  rotate[3] = vec4(0.0f, 0.0f, 0.0f, 1.0f);
  rotate /= determinant(rotate);

  normals[0] = normalize(rotate * vec4(normals[0], 1.0f)).xyz; 
  normals[1] = normalize(rotate * vec4(normals[1], 1.0f)).xyz; 
  normals[2] = normalize(rotate * vec4(normals[2], 1.0f)).xyz; 

  float epsilon = 0.000001;

  vec3 edge1 = vertices[2] - vertices[0];
  vec3 edge2 = vertices[1] - vertices[0];

  vec3 cross_rayDir_edge2 = cross(rayDir, edge2);
  float det = dot(edge1, cross_rayDir_edge2);

  if (det > -epsilon && det < epsilon){
    h.didHit = false;
    return h;
  }

  float invDet = 1.0 / det;

  vec3 orig_minus_vert0 = rayOrigin - vertices[0];

  float baryU = dot(orig_minus_vert0, cross_rayDir_edge2) * invDet;
  if (baryU < 0.0 || baryU > 1.0){
    h.didHit = false;
    return h;
  }

  vec3 cross_oriMinusVert0_edge1 = cross(orig_minus_vert0, edge1);

  float baryV = dot(rayDir, cross_oriMinusVert0_edge1) * invDet;
  if (baryV < 0.0 || baryU + baryV > 1.0){
    h.didHit = false;
    return h;
  }

  h.rayT = dot(edge2, cross_oriMinusVert0_edge1) * invDet;

  if (h.rayT < 0.0){
    h.didHit = false;
    return h;
  }

  float baryW = 1.0f - (baryU + baryV);
  // h.normal = normalize(cross(edge2, edge1));
  // h.normal = normalize(baryU * normals[0] + baryV * normals[1] + baryW * normals[1]);
  // h.position = untransformedRayOrig + rayDir * h.rayT;
  h.position = rayOrigin + rayDir * h.rayT;

  vec3 barycentric = barycentricCoords(vertices, h.position);

  h.normal = normalize(barycentric.x * normals[0] + barycentric.y * normals[1] + barycentric.z * normals[2]);
  // h.bary = vec3(baryU, baryV, baryW);
  h.bary = barycentric;

  return h;
}


mat4 lookat(vec3 eye, vec3 at, vec3 up){

  vec3 zAxis = normalize(at - eye);
  vec3 xAxis = normalize(cross(zAxis, up));
  vec3 yAxis = normalize(cross(xAxis, zAxis));

  zAxis = -zAxis;

  mat4 mat = {
    vec4(xAxis, 0),
    vec4(yAxis, 0),
    vec4(zAxis, 0),
    vec4(0, 0, 0, 1)
  };

  return mat;
}

vec3 getRayDir(float fov /* in degrees */, float aspectRatio) {
  vec2 texelCoord = gl_GlobalInvocationID.xy;
  vec2 ndc = vec2((texelCoord.x + 0.5) / (resolution[0]),
                  (texelCoord.y + 0.5) / (resolution[1]));

  vec2 pixelCamera;
  pixelCamera.x = ((2 * ndc.x) - 1) * aspectRatio * tan(radians(fov / 2));
  pixelCamera.y = ((2 * ndc.y) - 1) * tan(radians(fov / 2));

  vec3 rayDir = normalize((camToWorld * vec4(pixelCamera, -1.0f, 0)).xyz);
  // vec3 rayDir = normalize((lookat(vec3(0, 0, 0), cameraDir, vec3(0, 1, 0))) * vec4(pixelCamera, -1.0f, 0)).xyz;
  // vec3 rayDir = normalize((lookat(vec3(0, 0, 0), vec3(0, 1, 0), vec3(0, 1, 0))) * vec4(pixelCamera, -1.0f, 0)).xyz;

  return rayDir;
}


bool didIsectVolume(uint volumeIndex, vec3 rayDir, vec3 rayOrigin){

  float tx_1 = (bvhs[volumeIndex].corner1.x - rayOrigin.x) / rayDir.x;
  float tx_2 = (bvhs[volumeIndex].corner2.x - rayOrigin.x) / rayDir.x;

  float ty_1 = (bvhs[volumeIndex].corner1.y - rayOrigin.y) / rayDir.y;
  float ty_2 = (bvhs[volumeIndex].corner2.y - rayOrigin.y) / rayDir.y;

  float tz_1 = (bvhs[volumeIndex].corner1.z - rayOrigin.z) / rayDir.z;
  float tz_2 = (bvhs[volumeIndex].corner2.z - rayOrigin.z) / rayDir.z;

  float tx_min = min(tx_1, tx_2);
  float tx_max = max(tx_1, tx_2);

  float ty_min = min(ty_1, ty_2);
  float ty_max = max(ty_1, ty_2);

  float tz_min = min(tz_1, tz_2);
  float tz_max = max(tz_1, tz_2);

  float t_min = max(max(tx_min, ty_min), tz_min);
  float t_max = min(min(tx_max, ty_max), tz_max);

  if (t_max < 0) return false;
  
  if (t_min > t_max) return false;

  return true;
}


HitInfo closestSphereHIt(out uint index, vec3 rayDir, vec3 rayOrigin){

  HitInfo minHit;
  minHit.rayT = 1.0 / 0.0;
  minHit.didHit = false;

  uint minIndex = -1;
  
  for (int i = 0; i < spheres.length(); i++){

    HitInfo h = testSphereIntersect(rayOrigin, rayDir, spheres[i]);
    if (!h.didHit)
      continue;

    

    if (h.rayT < minHit.rayT){
      minHit = h;
      minIndex = i;
      minHit.didHit = true;
    }
  }
  
  index = minIndex;
  return minHit;
}


HitInfo didIsectTri(uint volumeIndex, vec3 rayDir, vec3 rayOrigin, out uint triIndex){


  uint triangle = bvhs[volumeIndex].triIndices[0];

  vec3 tempVerts[] = {
    verts[3 * triangle].position.xyz,
    verts[3 * triangle + 1].position.xyz,
    verts[3 * triangle + 2].position.xyz
  };

  vec3 tempNorms[] = {
    verts[3 * triangle].normal.xyz,
    verts[3 * triangle + 1].normal.xyz,
    verts[3 * triangle + 2].normal.xyz
  };

  // uint m = imageLoad(vertMeshRelTex, int(triangle)).r;
  uint m = vertMeshRel[triangle];
  // HitInfo h = triangleIntersect(temp, rayDir, rayOrigin, meshes[m].position.xyz);
  HitInfo h = triangleIntersect(tempVerts, tempNorms, rayDir, rayOrigin, meshes[m].transform);
  

  triIndex = triangle;
  return h;
}



HitInfo traverseBvh(out uint meshIndex, out uint triIndex, vec3 rayDir, vec3 rayOrigin){
  HitInfo minHit;
  minHit.rayT = 1.0 / 0.0;
  minHit.didHit = false;

  uint minMeshIndex = -1;
  uint minTriIndex = -1;
#ifdef NO_BVH
  for (uint i = 0; i < meshes.length(); i++){

    for (uint j = 0; j < meshes[i].numTriangles; j += 3){
      uint indexOffset = meshes[i].startingVertex;

      vec3 temp[] = {
        verts[j + indexOffset].position.xyz,
        verts[j + indexOffset + 1].position.xyz,
        verts[j + indexOffset + 2].position.xyz
      };

      uint index;

      HitInfo h = triangleIntersect(temp, rayDir, rayOrigin, meshes[i].transform);

      if (!h.didHit)
        continue;
      
      if (h.rayT < minHit.rayT){
        minHit.didHit = true;
        minHit = h;
        minMeshIndex = i;
        minTriIndex = indexOffset + j;
      }

    }


  }

  // meshIndex = minMeshIndex;
  // meshIndex = imageLoad(vertMeshRelTex, int(minTriIndex)).r;
  meshIndex = vertMeshRel[minTriIndex];
  triIndex = minTriIndex;
  return minHit;
#else
  int currentIndex = 0;
  while(currentIndex != -1) {

    if (!didIsectVolume(currentIndex, rayDir, rayOrigin)){
      currentIndex = bvhs[currentIndex].missIndex;
      continue;
    }

    if (bvhs[currentIndex].numTris != 0){
      uint tempTriIndex;
      HitInfo h = didIsectTri(currentIndex, rayDir, rayOrigin, tempTriIndex);

      if (!h.didHit){
        currentIndex = bvhs[currentIndex].hitIndex;
        continue;
      }

      if (h.rayT < minHit.rayT){
        minHit = h;
        minTriIndex = tempTriIndex;
      }
    }

    currentIndex = bvhs[currentIndex].hitIndex;
  }

  meshIndex = vertMeshRel[minTriIndex];
  triIndex = minTriIndex;
  return minHit;
#endif
}


vec3 getSpecularReflectedRay(float roughness, vec3 surfaceNormal, vec3 rayDir, 
                                inout uint seed, out float theta, out float phi, out vec3 microfacetN, float weight){




  float alpha = roughness * roughness;
  float alpha2 = alpha * alpha;

  uint temp = seed;
  
  float xi_1 = random(temp);
  float xi_2 = random(temp);


  seed = temp;

  theta = atan(alpha * sqrt(xi_1 / (1 - xi_1)));
  // theta = atan(sqrt(-alpha2 * log(1 - xi_1)));
  phi = 2 * PI * xi_2;

  microfacetN = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
  // normal = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));
  microfacetN = (lookat(vec3(0, 0, 0), -surfaceNormal, vec3(0, 1, 0)) * vec4(microfacetN, 0)).xyz;
  microfacetN = normalize(microfacetN);

  vec3 reflected = reflect(rayDir, microfacetN);

  return reflected;

}


vec3 getDiffuseReflectedRay(vec3 surfaceNormal, inout uint seed, out float theta, out float phi, out float weight){
// SRC (https://www.shadertoy.com/view/3lB3DR, Buffer A, lines 219 through 235) {
  float cosTheta2 = random(seed);
  float cosTheta = sqrt(cosTheta2);
  float sinTheta = sqrt(1.0f - cosTheta2);

  phi = 2.0f * PI * random(seed);

  vec3 t = normalize(cross(surfaceNormal.yzx, surfaceNormal));
  vec3 b = cross(surfaceNormal, t);
  
  vec3 l = (t * cos(phi) + b * sin(phi)) * sinTheta + surfaceNormal * cosTheta;

  float pdf = (1.0f / PI) * cosTheta;
  weight = (0.5f / PI) / (pdf + 1e-6);

  return l;
// }
}

float lambertianPDF(vec3 view, vec3 normal){
  return dot(view, normal) / PI;
}

vec3 lambertianBRDF(vec3 view, vec3 normal, vec3 albedo){
  return (albedo);
}


vec3 calculateFresnel(float VdotH, vec3 f0){

  return f0 + ((1.0 - f0) * pow(1.0 - VdotH, 5.0));
}

float GGXDistribution(float alpha, float NdotH){

  float alpha2 = alpha * alpha;

  float b = ((alpha2 - 1.0) * NdotH * NdotH) + 1;

  if (alpha < 0.001)
    return 1;

  if (!(NdotH > 0))
    return 0;

  return (alpha2 / (PI * b * b));
}

float beckmannDist(float alpha, float NdotH){

  float alpha2 = alpha * alpha;

  float theta = acos(NdotH);

  float den = PI * alpha2 * pow(NdotH, 4.0);
  float num = exp(-(tan(theta) * tan(theta)) / alpha2);

  return num / den;
}

float schlickG1(float NdotX, float alpha){

  float k = max(alpha / 2, 0.001);
  return NdotX / (NdotX * (1 - k) + k);
}

float smithG2(float NdotV, float NdotL, float alpha){
  return schlickG1(NdotV, alpha) * schlickG1(NdotL, alpha);
}


vec3 GGXbrdf(vec3 V, vec3 L, vec3 N, Material mat){


  vec3 H = normalize(V + L);

  float NdotV = clamp(dot(N, V), 0.0, 1.0);
  float NdotL = clamp(dot(N, L), 0.0, 1.0);
  float NdotH = clamp(dot(N, H), 0.0, 1.0);
  float VdotH = clamp(dot(V, H), 0.0, 1.0);
  float LdotH = clamp(dot(L, H), 0.0, 1.0);

  mat.roughness.x = max(mat.roughness.x, 0.032);

  float alpha = mat.roughness.x * mat.roughness.x;

  vec3 f0 = vec3(0.16 * mat.reflectance * mat.reflectance);
  f0 = mix(f0, mat.albedo.xyz, mat.metallic);

  vec3 F = calculateFresnel(VdotH, f0);
  float D = GGXDistribution(alpha, NdotH);
  float G = smithG2(NdotV, NdotL, alpha);

  vec3 brdf = (F * D * G) / (4 * max(NdotL, 0.001) * max(NdotV, 0.001));
  return brdf;
}

vec2 interpTexel(vec3 bary, uint vertIndex, int texID){

  float u = bary.x;
  float v = bary.y;
  float w = bary.z;

  vec2 texel = verts[vertIndex].texelCoord * u + verts[vertIndex + 1].texelCoord * v + verts[vertIndex + 2].texelCoord * w;

  
  return vec2(texel.x, 1.0f - texel.y);
  // return texel;
}

float GGXpdf(float roughness, vec3 H, vec3 N, vec3 L, float reflectance){

  roughness = max(roughness, 0.032);

  float alpha = roughness * roughness;

  if (roughness == 0)
    return 1;

  float t = reflectance * reflectance;
  
  float alpha2 = alpha * alpha;


  float NdotH = clamp(dot(N, H), 0.0, 1.0);
  float LdotH = clamp(dot(L, H), 0.0, 1.0);
  float NdotL = clamp(dot(N, L), 0.0, 1.0);


  float term1 = (1 - t) * NdotL / PI;

  float num = max(GGXDistribution(alpha, NdotH), 0.001) * max(NdotH, 0.001);

  float term2 = (t * num) / (4 * LdotH);

  return term1 + term2;
}

vec4 trace(vec3 rayDir, vec4 bgColour, inout uint seed){
  
  vec3 rayOrigin = cameraPos;

  // if (didIsectVolume(0, rayDir, rayOrigin))
  //   return vec4(1, 0, 1, 1);

  vec3 colour = vec3(0, 0, 0);
  vec3 throughput = vec3(1.0, 1.0, 1.0);

  HitInfo hit;
  uint sphereIndex;
  uint meshIndex;
  uint triIndex;

  Material mat;
  float mult = 1.0f;

  // uint seed = frameNum * (gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(resolution.y)) * time;
  uint prevSeed = seed;

  float bgIntensity = 1.0f;

  
  for (int i = 0; i <= maxBounces; i++){


    
    HitInfo sphereHit = closestSphereHIt(sphereIndex, rayDir, rayOrigin);
    HitInfo triHit = traverseBvh(meshIndex, triIndex, rayDir, rayOrigin);

    bool isTriCloser = triHit.rayT < sphereHit.rayT;

    isTriCloser = true;

    hit = isTriCloser ? triHit : sphereHit;
    mat = isTriCloser ? materials[meshes[meshIndex].materialID] :
                        materials[spheres[sphereIndex].materialID];                       
    
    uint tempVertIndex = triIndex * 3;

    vec2 textureCoord = interpTexel(hit.bary, tempVertIndex, mat.textureID);
    // return vec4(textureCoord, 0.0f, 1.0f);
    // return vec4(hit.bary.xyz, 1.0f);

    if (mat.displacementMapID != -1){
      hit.position += hit.normal * texture(textures[mat.displacementMapID], textureCoord).x * mat.intensity.x;
    }

    mat.albedo = mat.textureID != -1 ? texture(textures[mat.textureID], textureCoord) : mat.albedo;
    mat.emission = mat.emissiveMapID != -1 ? texture(textures[mat.emissiveMapID], textureCoord) : mat.emission;
    mat.roughness = mat.roughnessMapID != -1 ? texture(textures[mat.roughnessMapID], textureCoord).xy : mat.roughness;
    mat.metallic = mat.metallicMapID != -1 ? texture(textures[mat.metallicMapID], textureCoord).x : mat.metallic;
    mat.reflectance = mat.specularMapID != -1 ? texture(textures[mat.specularMapID], textureCoord).x : mat.reflectance;
    mat.opacity = mat.opacityMapID != -1 ? texture(textures[mat.opacityMapID], textureCoord).x : mat.opacity;
    hit.normal = mat.normalMapID != -1 ? normalize(texture(textures[mat.normalMapID], textureCoord).xyz) : hit.normal;

    mat4 rotate = meshes[meshIndex].transform;
    rotate[3] = vec4(0.0f, 0.0f, 0.0f, 1.0f);
    rotate /= determinant(rotate);

    hit.normal = (rotate * vec4(hit.normal, 1.0f)).xyz;
    
    // return vec4(hit.normal, 1.0f);
    
    // Perfectly vertical normals don't work properly, so this is needed to offset it by a tiny amount
    hit.normal += 0.000000001;

    if (!hit.didHit){
      
      if (i != 0){
        colour += bgColour.xyz * throughput * bgIntensity;
      }

      else
        colour +=  bgColour.xyz * throughput;


      break;
    }


    float theta, phi;

    float xi = random(seed);
    bool isSpecular = false;

    bool refracted = false;

    if (mat.metallic == 1.0f){
      isSpecular = true;
      refracted = false;
      mat.opacity = 1.0f;
      mat.reflectance = 1.0f;
    }

    if (xi <= mat.metallic){
      mat.metallic = 1.0f;
      isSpecular = true;
      refracted = false;
      mat.opacity = 1.0f;
      mat.reflectance = 1.0f;
    }

    xi = random(seed);

    if (xi <= mat.reflectance * mat.reflectance){
      isSpecular = true;
      refracted = false;
      mat.opacity = 1.0f;
    }

    xi = random(seed);
    if (xi < 1 - mat.opacity){
      mat.metallic = 0.0f;
      mat.reflectance = 0.0f;
      isSpecular = false;
      refracted = true;
    }


  


    float weight;


    vec3 microfacetN;
    vec3 reflectedRay = isSpecular ? getSpecularReflectedRay(mat.roughness.x, hit.normal, rayDir, seed, theta, phi, microfacetN, weight) : 
                                    getDiffuseReflectedRay(hit.normal, seed, theta, phi, weight);


    if (dot(reflectedRay, hit.normal) <= 0.001){
      
      colour += throughput * mat.emission.xyz * mat.intensity.x;
      break;
    }
    

  

    vec3 brdf = isSpecular ? GGXbrdf(-rayDir, reflectedRay, hit.normal, mat) : lambertianBRDF(-rayDir, hit.normal, mat.albedo.xyz);


    vec3 H = normalize(-rayDir + reflectedRay);
    // float pdf = isSpecular ?  GGXpdf(mat.roughness.x, H, hit.normal, reflectedRay, mat.reflectance) : lambertianPDF(-rayDir, hit.normal);
    float pdf = isSpecular ?  GGXpdf(mat.roughness.x, H, hit.normal, reflectedRay, mat.reflectance) : 1 / weight;

    // if (isSpecular && mat.roughness.x == 0)
    //   pdf = 1.0;


    if (isSpecular)
      weight = 1 / pdf;

    colour += throughput * mat.emission.xyz * mat.intensity.x;

    throughput *= brdf * weight * dot(hit.normal, reflectedRay);

    // if (isnan(colour.x) || isnan(colour.y) || isnan(colour.z) || isnan(pdf))
    //   return vec4(1, 0, 1, 1);
    



    rayDir = refracted ? refract(rayDir, -hit.normal, 1.5) : reflectedRay;
    vec3 offset = rayDir * 0.001;

    rayOrigin = hit.position + offset;
  }

  return vec4(colour, 1);
}


void main() {


  if (gl_GlobalInvocationID.x < uint(resolution[0]) && gl_GlobalInvocationID.y < uint(resolution[1])){
  
    vec4 colour = vec4(0, 0, 0, 1);


    float aspectRatio = (resolution[0]) / (resolution[1]);
    vec3 rayDir = getRayDir(fov, aspectRatio);

    float pixelLength = (2 * tan(radians(fov / 2)) * aspectRatio * blurStrength) / resolution[0];
    float pixelHeight = (2 * tan(radians(fov / 2)) * blurStrength) / resolution[1];


    uint seed = frameNum * gl_GlobalInvocationID.x * gl_GlobalInvocationID.y * time;
    

    for (int i = 0; i < raysPerPixel; i++){ 

      vec3 offset = vec3((random(seed) * 2 - 1) * pixelLength, (random(seed) * 2 - 1) * pixelHeight, 0);

      colour += trace(rayDir + offset, vec4(0.663, 0.965, 0.969, 1), seed) / raysPerPixel;
      // colour += trace(rayDir + offset, vec4(0, 0, 0, 1), seed) / raysPerPixel; 
    }


    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);




    if (frameNum == 1)
      imageStore(rendered, texelCoord, colour);

    else{

      vec4 prevColour = imageLoad(rendered, texelCoord);
      colour = ((frameNum - 1) * prevColour + colour) / frameNum;
      imageStore(rendered, texelCoord, colour);

    }
  }

}
