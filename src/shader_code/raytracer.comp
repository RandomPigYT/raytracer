/*Any piece of code wrapped in SRC(<source>){} indicates that the code has been copied from another location.
  The <source> specifies the source.*/

#version 450 core

#define NUM_INVOCATIONS_PER_GROUP_X 40
#define NUM_INVOCATIONS_PER_GROUP_Y 24

layout(local_size_x = NUM_INVOCATIONS_PER_GROUP_X,
       local_size_y = NUM_INVOCATIONS_PER_GROUP_Y, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform image2D rendered;
layout(r32ui, binding = 1) uniform uimage1D vertMeshRelTex;


#define RAND_MAX 0xffffffffu
#define PI radians(180)

struct Vertex {
  vec4 position;
  vec4 normal;
  vec2 texelCoord;
};

struct Material {
  vec4 albedo;
  vec4 emission;
  vec4 intensity;
  vec4 refractiveIndex;
  vec2 roughness;
  float metallic;
  float reflectance;
};

struct Mesh {
  uint startingVertex;
  uint numTriangles;
  uint materialID;
  uint objectID;
  vec4 position;
};

struct Object {
  vec3 pos;
  uint id;
};

struct Sphere {
  vec4 position;
  float radius;

  uint materialID;
};

struct HitInfo {
  bool didHit;
  vec3 normal;
  float rayT;
  vec3 position;
};

struct Bvh {
  vec4 corner1;
  vec4 corner2;
  int hitIndex;
  int missIndex;
  uint numTris;
  uvec4 triIndices;
};

layout(std430, binding = 0) buffer Verts { Vertex verts[]; };

layout(std430, binding = 4) buffer sphereBuf { Sphere spheres[]; };

layout(std140, binding = 1) buffer Materials { Material materials[]; };

layout(std140, binding = 2) buffer Meshes { Mesh meshes[]; };

layout(std140, binding = 3) buffer Objects { Object objects[]; };

layout(std430, binding = 5) buffer Bvhs { Bvh bvhs[]; };

uniform vec3 cameraPos;
uniform vec3 cameraDir;

uniform uint raysPerPixel;
uniform uint maxBounces;

uniform vec2 resolution;

uniform uint time;
uniform uint frameNum;

uniform mat4 camToWorld;

uniform float fov;
uniform float blurStrength;

uint pcg_hash(uint inp) {
  uint state = inp * 747796405u + 2891336453u;
  uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
  return (word >> 22u) ^ word;
}

float random(inout uint seed) {
  seed = pcg_hash(seed);

  return seed / float(RAND_MAX);
}

HitInfo testSphereIntersect(vec3 rayOrigin, vec3 rayDir, Sphere s) {
  HitInfo h;
  h.didHit = true;

  vec3 translatedRayOrig = rayOrigin - s.position.xyz;

  float a = dot(rayDir, rayDir);
  float b = dot(translatedRayOrig, rayDir) * 2;
  float c = dot(translatedRayOrig, translatedRayOrig) - (s.radius * s.radius);

  float discriminant = (b * b) - (4 * a * c);

  if (discriminant < 0) {
    h.didHit = false;
    return h;
  }

  float t_0 = (-b - sqrt(discriminant)) / (2 * a);
  float t_1 = (-b + sqrt(discriminant)) / (2 * a);

  if (t_0 < 0 && t_1 < 0) {
    h.didHit = false;
    return h;
  }

  h.rayT = t_0 >= 0 ? t_0 : t_1;
  h.position = rayOrigin + rayDir * h.rayT;
  h.normal = normalize(h.position - s.position.xyz);

  return h;
}

HitInfo triangleIntersect(vec3 vertices[3], vec3 rayDir, vec3 rayOrigin, vec3 pos){
  HitInfo h;
  h.didHit = true;
  
  vec3 untransformedRayOrig = rayOrigin;
  rayOrigin -= pos;

  float epsilon = 0.000001;

  vec3 edge1 = vertices[2] - vertices[0];
  vec3 edge2 = vertices[1] - vertices[0];

  vec3 cross_rayDir_edge2 = cross(rayDir, edge2);
  float det = dot(edge1, cross_rayDir_edge2);

  if (det > -epsilon && det < epsilon){
    h.didHit = false;
    return h;
  }

  float invDet = 1.0 / det;

  vec3 orig_minus_vert0 = rayOrigin - vertices[0];

  float baryU = dot(orig_minus_vert0, cross_rayDir_edge2) * invDet;
  if (baryU < 0.0 || baryU > 1.0){
    h.didHit = false;
    return h;
  }

  vec3 cross_oriMinusVert0_edge1 = cross(orig_minus_vert0, edge1);

  float baryV = dot(rayDir, cross_oriMinusVert0_edge1) * invDet;
  if (baryV < 0.0 || baryU + baryV > 1.0){
    h.didHit = false;
    return h;
  }

  h.rayT = dot(edge2, cross_oriMinusVert0_edge1) * invDet;

  if (h.rayT < 0.0){
    h.didHit = false;
    return h;
  }

  h.normal = normalize(cross(edge2, edge1));
  h.position = untransformedRayOrig + rayDir * h.rayT;

  return h;
}


mat4 lookat(vec3 eye, vec3 at, vec3 up){

  vec3 zAxis = normalize(at - eye);
  vec3 xAxis = normalize(cross(zAxis, up));
  vec3 yAxis = normalize(cross(xAxis, zAxis));

  zAxis = -zAxis;

  mat4 mat = {
    vec4(xAxis, 0),
    vec4(yAxis, 0),
    vec4(zAxis, 0),
    vec4(0, 0, 0, 1)
  };

  return mat;
}

vec3 getRayDir(float fov /* in degrees */, float aspectRatio) {
  vec2 texelCoord = gl_GlobalInvocationID.xy;
  vec2 ndc = vec2((texelCoord.x + 0.5) / (resolution[0]),
                  (texelCoord.y + 0.5) / (resolution[1]));

  vec2 pixelCamera;
  pixelCamera.x = ((2 * ndc.x) - 1) * aspectRatio * tan(radians(fov / 2));
  pixelCamera.y = ((2 * ndc.y) - 1) * tan(radians(fov / 2));

  vec3 rayDir = normalize((camToWorld * vec4(pixelCamera, -1.0f, 0)).xyz);
  // vec3 rayDir = normalize((lookat(vec3(0, 0, 0), cameraDir, vec3(0, 1, 0))) * vec4(pixelCamera, -1.0f, 0)).xyz;
  // vec3 rayDir = normalize((lookat(vec3(0, 0, 0), vec3(0, 1, 0), vec3(0, 1, 0))) * vec4(pixelCamera, -1.0f, 0)).xyz;

  return rayDir;
}


HitInfo closestSphereHIt(out uint index, vec3 rayDir, vec3 rayOrigin){

  HitInfo minHit;
  minHit.rayT = 1.0 / 0.0;
  minHit.didHit = false;

  uint minIndex = -1;
  
  for (int i = 0; i < spheres.length(); i++){

    HitInfo h = testSphereIntersect(rayOrigin, rayDir, spheres[i]);
    if (!h.didHit)
      continue;

    

    if (h.rayT < minHit.rayT){
      minHit = h;
      minIndex = i;
      minHit.didHit = true;
    }
  }
  
  index = minIndex;
  return minHit;
}

HitInfo closestTriangleHit(out uint meshIndex, out uint triIndex, vec3 rayDir, vec3 rayOrigin){
  HitInfo minHit;
  minHit.rayT = 1.0 / 0.0;
  minHit.didHit = false;

  uint minMeshIndex = -1;
  uint minTriIndex = -1;

  for (uint i = 0; i < meshes.length(); i++){

    for (uint j = 0; j < meshes[i].numTriangles; j += 3){
      uint indexOffset = meshes[i].startingVertex;

      vec3 temp[] = {
        verts[j + indexOffset].position.xyz,
        verts[j + indexOffset + 1].position.xyz,
        verts[j + indexOffset + 2].position.xyz
      };

      uint index;

      HitInfo h = triangleIntersect(temp, rayDir, rayOrigin, meshes[i].position.xyz);

      if (!h.didHit)
        continue;
      
      if (h.rayT < minHit.rayT){
        minHit.didHit = true;
        minHit = h;
        minMeshIndex = i;
        minTriIndex = indexOffset + j;
      }

    }


  }

  meshIndex = minMeshIndex;
  triIndex = minTriIndex;
  return minHit;
}


vec3 getSpecularReflectedRay(float roughness, vec3 surfaceNormal, vec3 rayDir, 
                                inout uint seed, out float theta, out float phi, out vec3 microfacetN, float weight){




  float alpha = roughness * roughness;
  float alpha2 = alpha * alpha;

  uint temp = seed;
  
  float xi_1 = random(temp);
  float xi_2 = random(temp);


  seed = temp;

  theta = atan(alpha * sqrt(xi_1 / (1 - xi_1)));
  // theta = atan(sqrt(-alpha2 * log(1 - xi_1)));
  phi = 2 * PI * xi_2;

  microfacetN = vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));
  // normal = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));
  microfacetN = (lookat(vec3(0, 0, 0), -surfaceNormal, vec3(0, 1, 0)) * vec4(microfacetN, 0)).xyz;
  microfacetN = normalize(microfacetN);

  vec3 reflected = reflect(rayDir, microfacetN);

  return reflected;

}


vec3 getDiffuseReflectedRay(vec3 surfaceNormal, inout uint seed, out float theta, out float phi, out float weight){
// SRC (https://www.shadertoy.com/view/3lB3DR, Buffer A, lines 219 through 235) {
  float cosTheta2 = random(seed);
  float cosTheta = sqrt(cosTheta2);
  float sinTheta = sqrt(1.0f - cosTheta2);

  phi = 2.0f * PI * random(seed);

  vec3 t = normalize(cross(surfaceNormal.yzx, surfaceNormal));
  vec3 b = cross(surfaceNormal, t);
  
  vec3 l = (t * cos(phi) + b * sin(phi)) * sinTheta + surfaceNormal * cosTheta;

  float pdf = (1.0f / PI) * cosTheta;
  weight = (0.5f / PI) / (pdf + 1e-6);

  return l;
// }
}

float lambertianPDF(vec3 view, vec3 normal){
  return dot(view, normal) / PI;
}

vec3 lambertianBRDF(vec3 view, vec3 normal, vec3 albedo){
  return (albedo);
}


vec3 calculateFresnel(float VdotH, vec3 f0){

  return f0 + ((1.0 - f0) * pow(1.0 - VdotH, 5.0));
}

float GGXDistribution(float alpha, float NdotH){

  float alpha2 = alpha * alpha;

  float b = ((alpha2 - 1.0) * NdotH * NdotH) + 1;

  if (alpha < 0.001)
    return 1;

  if (!(NdotH > 0))
    return 0;

  return (alpha2 / (PI * b * b));
}

float beckmannDist(float alpha, float NdotH){

  float alpha2 = alpha * alpha;

  float theta = acos(NdotH);

  float den = PI * alpha2 * pow(NdotH, 4.0);
  float num = exp(-(tan(theta) * tan(theta)) / alpha2);

  return num / den;
}

float schlickG1(float NdotX, float alpha){

  float k = max(alpha / 2, 0.001);
  return NdotX / (NdotX * (1 - k) + k);
}

float smithG2(float NdotV, float NdotL, float alpha){
  return schlickG1(NdotV, alpha) * schlickG1(NdotL, alpha);
}


vec3 GGXbrdf(vec3 V, vec3 L, vec3 N, Material mat){


  vec3 H = normalize(V + L);

  float NdotV = clamp(dot(N, V), 0.0, 1.0);
  float NdotL = clamp(dot(N, L), 0.0, 1.0);
  float NdotH = clamp(dot(N, H), 0.0, 1.0);
  float VdotH = clamp(dot(V, H), 0.0, 1.0);
  float LdotH = clamp(dot(L, H), 0.0, 1.0);

  mat.roughness.x = max(mat.roughness.x, 0.032);

  float alpha = mat.roughness.x * mat.roughness.x;

  vec3 f0 = vec3(0.16 * mat.reflectance * mat.reflectance);
  f0 = mix(f0, mat.albedo.xyz, mat.metallic);

  vec3 F = calculateFresnel(VdotH, f0);
  float D = GGXDistribution(alpha, NdotH);
  float G = smithG2(NdotV, NdotL, alpha);

  vec3 brdf = (F * D * G) / (4 * max(NdotL, 0.001) * max(NdotV, 0.001));
  return brdf;
}


float GGXpdf(float roughness, vec3 H, vec3 N, vec3 L, float reflectance){

  roughness = max(roughness, 0.032);

  float alpha = roughness * roughness;

  if (roughness == 0)
    return 1;

  float t = reflectance * reflectance;
  
  float alpha2 = alpha * alpha;


  float NdotH = clamp(dot(N, H), 0.0, 1.0);
  float LdotH = clamp(dot(L, H), 0.0, 1.0);
  float NdotL = clamp(dot(N, L), 0.0, 1.0);


  float term1 = (1 - t) * NdotL / PI;

  float num = max(GGXDistribution(alpha, NdotH), 0.001) * max(NdotH, 0.001);

  float term2 = (t * num) / (4 * LdotH);

  return term1 + term2;
}

vec4 trace(vec3 rayDir, vec4 bgColour, inout uint seed){

  
  vec3 rayOrigin = cameraPos;

  vec3 colour = vec3(0, 0, 0);
  vec3 throughput = vec3(1.0, 1.0, 1.0);

  HitInfo hit;
  uint sphereIndex;
  uint meshIndex;
  uint triIndex;

  Material mat;
  float mult = 1.0f;

  // uint seed = frameNum * (gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * uint(resolution.y)) * time;
  uint prevSeed = seed;

  float bgIntensity = 1.0f;

  for (int i = 0; i <= maxBounces; i++){


    
    HitInfo sphereHit = closestSphereHIt(sphereIndex, rayDir, rayOrigin);
    HitInfo triHit = closestTriangleHit(meshIndex, triIndex, rayDir, rayOrigin);

    bool isTriCloser = triHit.rayT < sphereHit.rayT;

    hit = isTriCloser ? triHit : sphereHit;
    mat = isTriCloser ? materials[meshes[meshIndex].materialID] :
                        materials[spheres[sphereIndex].materialID];                       
    
    // Perfectly vertical normals don't work properly, so this is needed to offset it by a tiny amount
    hit.normal += 0.000000001;

    if (!hit.didHit){
      
      if (i != 0){
        colour += bgColour.xyz * throughput * bgIntensity;
      }

      else
        colour +=  bgColour.xyz * throughput;


      break;
    }


    float theta, phi;

    float xi = random(seed);
    bool isSpecular = false;

    float probability = 1.0f;

    if (xi <= mat.reflectance * mat.reflectance){
      isSpecular = true;
    }


    float weight;


    vec3 microfacetN;
    vec3 reflectedRay = isSpecular ? getSpecularReflectedRay(mat.roughness.x, hit.normal, rayDir, seed, theta, phi, microfacetN, weight) : 
                                    getDiffuseReflectedRay(hit.normal, seed, theta, phi, weight);


    if (dot(reflectedRay, hit.normal) <= 0.001){
      
      colour += throughput * mat.emission.xyz * mat.intensity.x;
      break;
    }
    

  

    vec3 brdf = isSpecular ? GGXbrdf(-rayDir, reflectedRay, hit.normal, mat) : lambertianBRDF(-rayDir, hit.normal, mat.albedo.xyz);


    vec3 H = normalize(-rayDir + reflectedRay);
    // float pdf = isSpecular ?  GGXpdf(mat.roughness.x, H, hit.normal, reflectedRay, mat.reflectance) : lambertianPDF(-rayDir, hit.normal);
    float pdf = isSpecular ?  GGXpdf(mat.roughness.x, H, hit.normal, reflectedRay, mat.reflectance) : 1 / weight;

    // if (isSpecular && mat.roughness.x == 0)
    //   pdf = 1.0;


    if (isSpecular)
      weight = 1 / pdf;

    colour += throughput * mat.emission.xyz * mat.intensity.x;

    throughput *= brdf * weight * dot(hit.normal, reflectedRay);

    // if (isnan(colour.x) || isnan(colour.y) || isnan(colour.z) || isnan(pdf))
    //   return vec4(1, 0, 1, 1);
    



    rayDir = reflectedRay;
    vec3 offset = rayDir * 0.001;

    rayOrigin = hit.position + offset;
  }

  return vec4(colour, 1);
}


void main() {

  
  vec4 colour = vec4(0, 0, 0, 1);


  float aspectRatio = (resolution[0]) / (resolution[1]);
  vec3 rayDir = getRayDir(fov, aspectRatio);

  float pixelLength = (2 * tan(radians(fov / 2)) * aspectRatio * blurStrength) / resolution[0];
  float pixelHeight = (2 * tan(radians(fov / 2)) * blurStrength) / resolution[1];


  uint seed = frameNum * gl_GlobalInvocationID.x * gl_GlobalInvocationID.y * time;
  

  for (int i = 0; i < raysPerPixel; i++){ 

    vec3 offset = vec3((random(seed) * 2 - 1) * pixelLength, (random(seed) * 2 - 1) * pixelHeight, 0);

    colour += trace(rayDir + offset, vec4(0.663, 0.965, 0.969, 1), seed) / raysPerPixel;
    // colour += trace(rayDir + offset, vec4(0, 0, 0, 1), seed) / raysPerPixel; 
  }


  ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);




  if (gl_GlobalInvocationID.x < uint(resolution[0]) && gl_GlobalInvocationID.y < uint(resolution[1]) && frameNum == 1)
    imageStore(rendered, texelCoord, colour);

  else{

    vec4 prevColour = imageLoad(rendered, texelCoord);
    colour = ((frameNum - 1) * prevColour + colour) / frameNum;
    imageStore(rendered, texelCoord, colour);

  }

}
