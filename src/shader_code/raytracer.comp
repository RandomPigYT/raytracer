#version 450 core

#define NUM_INVOCATIONS_PER_GROUP_X              30
#define NUM_INVOCATIONS_PER_GROUP_Y 15

layout (local_size_x = NUM_INVOCATIONS_PER_GROUP_X, local_size_y = NUM_INVOCATIONS_PER_GROUP_Y, local_size_z = 1) in;

layout (rgba32f, binding = 0) uniform image2D rendered;




struct Vertex {
	
	vec4 position;
	vec4 normal;
	vec2 texelCoord;

};

struct Material {
	
	vec4 kd;
	vec4 ks;
	vec4 emission;
	vec4 intensity;
	vec2 alpha;

};

struct Mesh {
	
	uint startingVertex;
	uint numTriangles;
	uint materialID;
	uint objectID;

};

struct Object {

	vec3 pos;
	uint id;

};

struct Sphere {

	vec4 position;
	float radius;

	uint materialID;

};


layout (std430, binding = 0) buffer Verts{
	Vertex verts[];
};

layout (std430, binding = 4) buffer sphereBuf {

	Sphere spheres[];

};

layout (std140, binding = 1) buffer Materials {
	Material materials[];
};

layout (std140, binding = 2) buffer Meshes {
	Mesh meshes;
};

layout (std140, binding = 3) buffer Objects {
	Object objects;
};

uniform vec3 cameraPos;
uniform vec3 cameraDir;

uniform uint raysPerPixel;
uniform uint maxBounces;

uniform vec2 resolution;





vec2 testIntersect(Vertex v[3], vec3 rayOrigin, vec3 rayDir ){
	float epsilon = 0.0000001;

	vec3 positions[] = {v[2].position.xyz, v[1].position.xyz, v[0].position.xyz};

	
	
	vec3 edge1 = positions[1] - positions[0];
	vec3 edge2 = positions[2] - positions[0];

	vec3 cross_rayDir_edge2 = cross(rayDir, edge2);
	
	double det = dot(edge1, cross_rayDir_edge2);

	if (det < epsilon)
		return vec2(0, 0);

	if (det > -epsilon && det < epsilon)
		return vec2(0, 0);

	double invDet = 1 / det;

	vec3 origMinusPos0 =  rayOrigin - positions[0];

	double baryU = dot(origMinusPos0, cross_rayDir_edge2) * invDet;
	if (baryU < 0.0 || baryU > 1.0)
		return vec2(0, 0);
	
	
	vec3 cross_oriMinusPos0_edge1 = cross(origMinusPos0, edge1);

	double baryV = dot(rayDir, cross_oriMinusPos0_edge1) * invDet;
	if (baryV < 0 || baryU + baryV > 1.0)
		return vec2(0, 0);
	
	double rayT;

	rayT = dot(edge2, cross_oriMinusPos0_edge1) * invDet;
	return vec2(1, rayT);
}



bool testSphereIntersect(vec3 rayOrigin, vec3 rayDir, float radius){
	
	float a = dot(rayDir, rayDir);
	float b = dot(rayOrigin, rayDir) * 2;
	float c = dot(rayOrigin, rayOrigin) - (radius * radius);

	float descriminant = (b * b) - (4 * a * c);

	if (descriminant >= 0)
		return true;
	
	return false;
}


vec3 getRayDir(float fov /* in degrees */, float aspectRatio){
	
	
	vec2 texelCoord = gl_GlobalInvocationID.xy;

	

	vec2 ndc = vec2((texelCoord.x + 0.5) / (gl_NumWorkGroups.x * NUM_INVOCATIONS_PER_GROUP_X), (texelCoord.y + 0.5) / (gl_NumWorkGroups.y * NUM_INVOCATIONS_PER_GROUP_Y));

	
	vec2 pixelCamera;
	pixelCamera.x = ((2 * ndc.x) - 1) * (1920.0f / 1080.0f) * tan(radians(fov / 2));
	pixelCamera.y = (1 - (2 * ndc.y)) * tan(radians(fov / 2));

	vec3 rayDir = vec3(pixelCamera, -1.0f);


	return rayDir;
}



void main(){

	vec4 colour = vec4(0, 0, 0, 1);

	vec4 colours[] = {
vec4(0.725, 0.192, 0.831, 1),
vec4(0.498, 0.831, 0.192, 1),
vec4(0.192, 0.831, 0.725, 1),
vec4(0.831, 0.192, 0.498, 1),
vec4(0.831, 0.725, 0.192, 1),
vec4(0.498, 0.192, 0.831, 1),
vec4(0.192, 0.498, 0.831, 1),
vec4(0.725, 0.831, 0.192, 1),
vec4(0.192, 0.725, 0.831, 1),
vec4(0.831, 0.498, 0.192, 1),
vec4(0.498, 0.725, 0.192, 1),
vec4(0.725, 0.498, 0.192, 1)


	};


	float aspectRatio = (gl_NumWorkGroups.x * NUM_INVOCATIONS_PER_GROUP_X)/ (gl_NumWorkGroups.y * NUM_INVOCATIONS_PER_GROUP_Y);

	float minRayT = 1 / 0;
	int minIndex = -1;
	// vec3 rayDir = getRayDir(0.1, 90, ivec2(1920, 2080));
	vec3 rayDir = getRayDir(90, aspectRatio);


	for (int i = 0; i < verts.length(); i += 3){
		
		Vertex temp[] = {verts[i], verts[i + 1], verts[i + 2]};
		vec2 intersectResult = testIntersect(temp, cameraPos, rayDir);

		vec4 edge1 = verts[i + 1].position - verts[i].position;
		vec4 edge2 = verts[i + 2].position - verts[i].position;

		vec3 normal = normalize(cross(edge2.xyz, edge1.xyz));

		if (intersectResult[0] == 1){
			if (intersectResult[1] > 0)
				continue;


			if (intersectResult[1] < minRayT)
				minRayT = intersectResult[1];
				minIndex = i / 3;
			// colour = colours[i / 3];
			
		}

	}

	for (int i = 0; i < spheres.length(); i++){

		if (testSphereIntersect(cameraPos, rayDir, spheres[i].radius))
			colour = vec4(1, 0, 0, 1);

	}
		

	// colour = colours[minIndex % 12];
	




	ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);


	vec4 value = vec4(
		gl_GlobalInvocationID.xy / vec2(1920, 1080),
		0, 0
	);


	// imageStore(rendered, texelCoord, value);
	imageStore(rendered, texelCoord, colour);

}

